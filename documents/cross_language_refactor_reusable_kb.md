# 跨语言重构可复用知识库（Python -> Rust or any AI friendly language）

## 0. 文档定位与使用方式

- 目标：沉淀可跨项目复用的迁移方法、门禁机制、审计流程与反常识经验。
- 适用范围：以“旧实现 + 新实现并行验证”为核心的跨语言重构工程。
- 使用方式：按章节直接复用模板；每章都要求绑定证据文件与执行命令。
- 写作批次约束：本知识库采用分批写入，先骨架后正文，避免一次性堆砌导致失真。

### 0.1 双引擎主线（本文核心）

本文把跨语言迁移重构抽象为两个可组合的执行引擎：

- `Harness Engineering`：定义“如何协作执行”（权限分层、探索预算、主动求助、证据交付）。
- `CSV-Driven-Loop`：定义“如何推进任务”（台账驱动、原子任务循环、状态锁定、Review + Rewind）。

两者关系：

- Harness 解决“执行方法”与“交互质量”。
- CSV loop 解决“任务编排”与“状态一致性”。
- 两者叠加后，可同时控制速度、质量、可追溯性。

### 0.2 最小落地要求

若要把本文用于新项目，至少要先落地以下四项：

1. 一个可执行台账（CSV 或同等结构化系统）
2. 一个统一编排入口（支持 run_id 与 stage）
3. 一组硬门禁（schema/缺失/状态）+ 策略门禁（warning/strict）
4. 一套交互协议（何时自主、何时求助、如何提选项）

### 0.3 融合执行蓝图（Harness × CSV Loop）

下表给出“单个原子任务”从开始到收束的融合流程，可直接作为执行 checklist：

| 阶段 | Harness 侧动作 | CSV Loop 侧动作 | 必备产物 |
| --- | --- | --- | --- |
| S0 定义边界 | 明确成功标准、不可改范围、预算 | 读取候选任务行 | 任务边界说明 |
| S1 锁定任务 | 选择当前权限层级（L1-L4） | `未开始 -> 进行中` | 状态变更记录 |
| S2 实施与验证 | 在预算内自主探索，失败换策略 | 按验收项做最小实现与测试 | 命令日志与测试结果 |
| S3 触发求助（可选） | 达到阈值时提交选项型问题 | 保持任务仍为 `进行中` | 证据 + A/B/C 方案 |
| S4 审查回卷 | 汇总证据、核对边界 | 执行 Review + Rewind | 验收勾选清单 |
| S5 收束归档 | 输出变更、风险、未覆盖项 | `进行中 -> 已完成` | 提交记录 + 报告索引 |

执行约束：

- 同时只能有一个 in-progress 原子任务。
- 未完成 Review + Rewind 不得关闭任务。
- 未产出证据的“完成”视为无效。

## 1. 阶段验收总览模板（可复用）

### 1.1 验收结论结构

跨语言阶段验收建议固定为“结论先行 + 证据索引 + 风险边界”三段式，禁止只写“通过”而不带证据。

建议字段：

- 截止时间（UTC 与本地时区至少一种）
- 验收结论（通过 / 有条件通过 / 不通过）
- 任务台账状态（总数、已完成数、未完成数）
- 行为等价结论（关键指标是否对齐）
- 性能门禁结论（是否满足当前 profile 与 policy）
- 未闭环项与阻塞项（需显式列出）

可复制模板：

```md
#### 阶段验收结论
- 截止时间：`YYYY-MM-DDTHH:mm:ssZ`
- 验收结论：`通过 | 有条件通过 | 不通过`
- 台账状态：`总计 N，已完成 M，进行中 K，未开始 L`
- 行为等价：`通过 | 存在差异（列出差异）`
- 性能门禁：`通过 | 告警 | 失败（列出 pair_id）`
- 未闭环项：`无 | 列表`

#### 证据索引
- 任务台账：`<path>`
- 阶段审计：`<path>`
- 回归报告：`<path>`
- 门禁日志：`<path>`
```

### 1.2 最小证据集合

最小证据集合建议固定为 6 类；缺任意 1 类都不应宣布“阶段完成”。

| 证据类型 | 作用 | 本仓库示例 |
| --- | --- | --- |
| 台账状态快照 | 证明任务面闭环 | `issues.csv` |
| 阶段审计文档 | 证明过程面可追溯 | `docs/reviews/stage_review_sources.md`、`docs/reviews/stage_directory_audit.md`、`docs/reviews/stage_full_review_report.md` |
| 真实回归报告 | 证明结果面可对照 | `test/ord03_pipeline/reports/r3_ord03_latest.md`、`test/3-real-strategy/reports/r3_real_strategy_latest.md` |
| 等价/性能产物 | 证明机器可重放 | `reports/equiv/runs/<run_id>/`、`pair_perf_latest.*` |
| 规则校验结果 | 证明没有绕过红线 | `scripts/check_no_inline_tests.sh` 扫描结果 |
| 环境与依赖声明 | 证明边界已披露 | `P0_HANDOFF.md`、`tests/perf/PERF_PROTOCOL.md` |

跨项目迁移时，不必沿用同名文件，但应保持“一类证据一个稳定落点”。

### 1.3 回归报告判读口径

建议采用“语义指标优先，数量指标次之”的判读顺序：

1. 先看语义指标：`total_pnl`、`deals`、关键 action 分布、关键触发器分布。  
2. 再看规模指标：`submitted_orders`、`order_rows`、`trade_rows`。  
3. 最后看结构指标：字段口径、事件顺序、幂等键、schema 兼容性。

判读规则（可复用）：

- `一致`：关键语义指标完全对齐，且无结构性冲突。
- `条件一致`：关键语义对齐，但规模指标存在可解释偏差，需要在报告写明原因。
- `不一致`：关键语义指标不对齐，或存在不可解释偏差。

示例要点（本仓库）：

- ORD03 报告中 `submitted_orders` 有差异，但 `PLACE/CANCEL` 分布与 `order_rows` 对齐，不构成直接失败，应归入“条件一致并要求注释原因”。
- Real Strategy 报告关键指标 delta 全 0，可归入“一致”。

### 1.4 风险与边界声明

阶段验收必须包含边界声明，避免“离线通过”被误读为“全环境通过”。

最小声明项：

- 外部依赖边界：是否依赖 VPN、数据库、动态库、第三方服务
- 平台边界：Linux 与 Windows 是否都验证
- profile 边界：`offline` 与 `full` 覆盖范围差异
- 数据边界：夹具覆盖范围、是否包含边界样本
- 语义边界：是否保持 at-least-once、是否允许行为变更

可复制模板：

```md
#### 风险与边界声明
- 外部依赖：`...`
- 平台覆盖：`Linux:通过; Windows:通过/待验证`
- Profile 覆盖：`offline:通过; full:待验证`
- 已知风险：`RISK-xx ...`
- 不在本轮范围：`...`
```

## 2. 工作区文档体系与职责分层（可复用）

### 2.1 单一事实源与优先级规则

建议固定文档优先级，避免跨会话时“谁说了算”反复争论。

推荐顺序：

1. 任务台账（`issues.csv` 或等价任务系统）
2. `git log`/提交与变更文件
3. 当前实现代码与测试
4. 阶段审计文档
5. 临时交接文档（handoff / for-xxx）

冲突处理流程：

1. 先以台账状态判断是否完成。
2. 再用提交记录核对是否有对应落盘。
3. 再检查代码与测试是否支持该结论。
4. 最后修正过期交接文档，防止二次漂移。

### 2.2 阶段审计三件套

建议每个迁移项目固定三份审计文档，分别回答三个问题：

- `stage_review_sources`：阶段如何划分，证据来自哪里。
- `stage_directory_audit`：目录级质量如何，风险在哪一层。
- `stage_full_review_report`：全程结论是什么，还有哪些未闭环项。

职责分工建议：

- AI：维护索引完整性、补齐证据路径、生成初稿。
- 人审：确认口径、裁决风险级别、签收最终结论。

这三份文档可以合并为 1 份，但必须保留这三个视角。

### 2.3 运行手册与测试手册

跨语言重构中，`README` 与 `TESTING` 的职责应拆分：

- `README`：安装、构建、最小运行路径、口径变更说明。
- `TESTING`：测试目录结构、执行命令、门禁策略、失败排障。

复用要求：

- 每条关键命令都能直接执行，不依赖隐含上下文。
- 每条门禁策略都定义失败语义（硬失败 / 告警）。
- 每次规则变更同步更新手册，避免“代码已改、文档未改”。

### 2.4 交接文档与状态文档

交接文档价值很高，但只能作为“会话快照”，不能替代台账。

建议规范：

- handoff 文件必须包含“生成时间、适用分支、证据路径”。
- 状态查询命令读取 handoff 时，必须回查台账状态。
- 一旦发现冲突，以台账为准并回写交接文档。

典型问题（本仓库已出现）：

- 临时文档仍写“任务进行中”，但台账已全部完成。
- 该类漂移若不纠正，会导致重复劳动与错误决策。

### 2.5 典型漂移模式与修正机制

建议长期维护“漂移清单”，至少覆盖以下 4 类：

- 状态漂移：台账与 handoff 状态不一致。
- 规则漂移：流程文档引用的文件不存在或已改名。
- 执行漂移：规则已写但未纳入日常检查。
- 现实漂移：规范阈值与现有代码体量明显冲突。

可执行巡检命令（示例）：

```bash
# 1) 台账状态统计
python - <<'PY'
import csv
from collections import Counter
rows=list(csv.DictReader(open('issues.csv',encoding='utf-8-sig')))
print(Counter(r['State'] for r in rows))
PY

# 2) 禁内联测试检查
bash scripts/check_no_inline_tests.sh

# 3) 审计流程引用文件是否存在
ls docs/review_checklist.md docs/Agent.md

# 4) 会话总结是否落盘
find docs/summaries -maxdepth 2 -type f
```

修正机制建议：

1. 先补“事实差异”文档记录，不立即改业务代码。
2. 再补自动检查脚本或 CI 规则，防止再次发生。
3. 最后更新手册，使新成员可直接复用流程。

### 2.6 CSV-Driven-Loop 实施细则（通用协议）

建议把台账驱动写成明确协议，而不是“口头上按 CSV 做”。

#### 台账字段最小集合

- `ID`
- `Title`
- `Content`
- `Acceptance Criteria`
- `Review Requirements`
- `State`（`未开始 | 进行中 | 已完成`）
- `Labels`

#### 状态机（强约束）

仅允许：

- `未开始 -> 进行中`
- `进行中 -> 已完成`
- `进行中 -> 未开始`（仅回退场景，必须写原因）

禁止：

- 跳过 `进行中` 直接 `未开始 -> 已完成`
- 同一任务并行多人/多代理同时置 `进行中`

#### 原子循环协议

1. `Pick`：按规则选 1 条 `未开始` 任务。
2. `Lock`：将其置为 `进行中`。
3. `Build`：仅做任务边界内实现。
4. `Verify`：执行最小充分验证。
5. `Review + Rewind`：按验收项逐条打勾。
6. `Close`：置为 `已完成`，记录提交与证据。

#### 最小自动检查脚本（示例）

```bash
# 1) 检查是否存在多个进行中任务
python - <<'PY'
import csv
rows=list(csv.DictReader(open('issues.csv',encoding='utf-8-sig')))
in_progress=[r['ID'] for r in rows if r.get('State')=='进行中']
print('in_progress_count=',len(in_progress))
print('in_progress_ids=',in_progress)
PY

# 2) 检查状态枚举合法性
python - <<'PY'
import csv,sys
allowed={'未开始','进行中','已完成'}
rows=list(csv.DictReader(open('issues.csv',encoding='utf-8-sig')))
bad=[(r['ID'],r['State']) for r in rows if r.get('State') not in allowed]
print('bad=',bad)
sys.exit(1 if bad else 0)
PY
```

#### 提交记录规则（建议）

- 一个原子任务一个提交
- 提交信息包含任务 ID
- 提交前 `git diff --name-only` 确认未越界
- 回退任务必须在台账写明回退原因

## 3. 跨语言等价验证体系（可复用）

### 3.1 测试资产化原则（先拆测试，再迁移）

跨语言重构中，“先拆测试、后迁移实现”比“边改边补测”更稳健。核心目标是把测试从业务源码中解耦，形成独立可回归资产。

可复用原则：

- 业务源码目录不放测试逻辑，测试统一放在 `tests/` 或等价目录。
- 单元、集成、等价、回归分层组织，避免“一个脚本测全部”。
- 任何行为变更都优先补等价测试，再改迁移代码。
- 测试命名包含语义，不使用泛化命名（如 `test1`、`smoke2`）。

建议迁移顺序：

1. 识别旧代码中的内联测试与隐式断言。
2. 抽离到独立测试文件并补齐公共 fixture/helpers。
3. 建立跨语言对照测试入口（Python baseline vs Rust candidate）。
4. 固化可重复执行命令与最小门禁。
5. 用脚本持续扫描防回归（禁止新内联测试回流）。

可执行检查模板：

```bash
# 1) 检查源码目录是否混入测试代码
rg -n "#\\[test\\]|#\\[cfg\\(test\\)\\]" <src_dir> -g "*.rs"

# 2) 运行最小等价回归
make test-equiv-rust
make test-equiv-python
```

### 3.2 等价编排（run_id + stages）模式

建议把等价验证流程编排为固定 stage，并统一 `run_id`，避免“某次报告找不到对应输入”。

推荐 stage：

- `rust`：Rust 等价测试
- `python`：Python 等价测试
- `pair_compare`：跨模式结果聚合比较
- `pair_gate`：门禁判定

关键机制：

- 每次运行生成唯一 `run_id`，并落地到统一目录。
- 支持按 stage 子集运行（便于局部回归）。
- 前序失败时后续 stage 默认 `blocked`，防止错误扩散。
- 仅在整轮通过时更新 `latest` 指针，避免把失败 run 标记为最新。

可复制命令：

```bash
# 全流程
python scripts/equiv/run_equiv_suite.py

# 只跑 rust + python
python scripts/equiv/run_equiv_suite.py --stages rust,python

# 只跑 compare + gate（复用已有 run_root）
python scripts/equiv/run_equiv_suite.py \
  --stages pair_compare,pair_gate \
  --run-root reports/equiv/runs/<run_id>
```

验收要点：

- 每个 stage 都有日志文件。
- `run_manifest.json` 包含 stage 状态与产物索引。
- 失败 run 可直接重放，不依赖人工回忆。

### 3.3 产物目录与 schema 版本化

等价产物应采用“目录规范 + schema 版本”双约束。目录负责定位，schema 负责字段稳定性。

推荐目录：

```text
reports/equiv/runs/<run_id>/
  run_manifest.json
  rust_equiv/summary.json
  python_equiv/summary.json
  pair_compare/
    raw/{python_legacy,rust_core,rust_pyo3}/*.json
    pair_perf_latest.csv
    pair_perf_latest.md
    pair_perf_latest.meta.json
```

版本治理建议：

- `schema_version` 每个关键 JSON 都必须携带。
- 主版本变更必须提供迁移说明和兼容策略。
- 默认执行“读兼容，写可切换”，避免一次性切断旧工具链。
- 任何字段改名都必须附带至少一个版本窗口的兼容读取逻辑。

### 3.4 负载等价与行为等价双重约束

跨语言比较必须同时回答两个问题：

- 行为是否等价（输出语义一致）？
- 负载是否等价（输入与执行路径可比）？

只看其一都会产生伪结论：

- 只看行为：可能“慢路径也通过”，掩盖性能退化。
- 只看性能：可能“路径不一致的快”，得到错误 speedup。

建议判定矩阵：

| 行为等价 | 负载等价 | 结论 |
| --- | --- | --- |
| 是 | 是 | 可给出性能结论 |
| 是 | 否 | 仅可给行为结论，不给 speedup |
| 否 | 是 | 优先修语义，不讨论性能 |
| 否 | 否 | 判定无效，需先修输入与路径 |

实现层要求：

- compare 报告必须输出 `comparable` 与 `load_equivalent` 字段。
- speedup 仅在 `comparable=true` 前提下计算和展示。
- mismatch 原因必须结构化输出（缺字段、路径不一致、计数不一致）。

### 3.5 失败可观测与可复盘要求

等价体系必须“失败可解释”。无法解释的失败与没有失败信号一样危险。

最小可观测要求：

- stage 级日志：每个 stage 独立 log 文件。
- 汇总清单：`run_manifest.json` 记录状态、命令、耗时、产物路径。
- 对比元数据：包含 `run_id`、输入哈希、生成时间。
- 失败分类：`failed`、`blocked`、`dry_run` 分层，禁止一律写失败。

复盘步骤模板：

1. 打开 `run_manifest.json` 确认失败 stage。
2. 按 `log_path` 定位原始错误。
3. 若失败在 compare/gate，优先核查 `run_id` 与输入哈希一致性。
4. 补最小复现命令并写入审计文档。

最小复盘产物：

- 一个可直接执行的复现命令
- 一份明确根因归类（数据、代码、配置、环境）
- 一条防回归措施（测试或门禁）

## 4. 性能对比与 CI 门禁体系（可复用）

### 4.1 pair_manifest 设计方法

`pair_manifest` 是跨语言性能平台的核心契约，不是普通配置表。其职责是定义“谁和谁可比、在什么边界下可比”。

建议最小字段：

- `pair_id`：语义单元 ID
- `py_path` / `rs_path`：实现映射路径
- `fixture_path`：输入夹具
- `mode_support`：支持模式集合
- `dependency_level`：依赖级别（如 `offline` / `external_blocked`）
- `profile`：归属 profile（`offline` / `full`）
- `workload_equivalence_status`：负载等价状态（`verified` / `partial` / `pending`)

设计规则：

- 映射按“行为语义等价”，不能只按文件名相似度。
- 外部依赖 pair 必须显式标记，不允许隐式混入离线集。
- 负载等价未 `verified` 的 pair，默认不能直接用于速度结论。

### 4.2 compare 脚本的可比性约束

compare 层负责“把可比性写进结果”，而不只是输出一张速度表。

建议强制能力：

- 读取并校验 schema。
- 读取并校验可观测指标契约。
- 计算输入文件哈希与 `compare_run_id`。
- 输出 workload profile 与 load equivalence 矩阵。
- 仅在满足可比条件时给 speedup 字段。

报告中必须可回答：

- 这组结果是否来自同一输入语义？
- 这组结果是否来自同一负载强度？
- 这组结果是否可用于性能结论？

### 4.3 gate 脚本的硬失败与策略失败分层

门禁建议分两层，避免把所有问题混成一个退出码语义：

- 硬失败（必须 fail）
- 策略失败（按 policy 决定）

硬失败典型条件：

- 必需结果文件缺失
- JSON/schema 非法
- summary 覆盖不完整
- 状态非 `ok`
- `run_id` / 输入哈希不一致
- `compare_run_id` 不一致

策略失败典型条件：

- `unstable` pair 出现（`warning` 仅告警，`strict` 失败）

可复制 policy 约定：

- 日常 PR：`warning`
- 发布前或基线冻结：`strict`

### 4.4 offline/full 双 profile 策略

双 profile 的目标是把“可重复离线验证”与“外部依赖场景验证”解耦，而不是制造两套标准。

策略建议：

- `offline`：默认 profile，要求稳定、可在 CI 常态运行。
- `full`：`offline` 的超集，包含外部依赖 pair（如需网络、动态库、专有组件）。

治理要点：

- 两个 profile 的结果目录必须物理隔离，防止互相覆盖。
- 所有 `external_blocked` pair 只能进入 `full`。
- 报告必须明确写明当前 profile，避免误读覆盖范围。

### 4.5 CI 工作流接入与产物归档

CI 的职责不是“代替分析”，而是稳定执行与留痕。推荐把性能对比流程做成独立 workflow。

接入建议：

- 触发条件仅覆盖相关目录（脚本、协议、夹具、门禁文档）。
- CI 固定安装依赖并构建扩展后再执行全流程命令。
- 必须上传原始结果、summary、baseline、审计产物。
- `if-no-files-found: error`，防止空上传被误判为成功。

产物归档建议：

- 按运行 ID 或 CI run_id 命名 artifact。
- 保留 raw 数据与 summary，支持二次离线审计。
- 在 PR 说明中引用 artifact 路径，便于 reviewer 复查。

## 5. 人审 + AI 驱动协作范式（可复用）

### 5.1 角色分工模型（人负责裁决，AI负责执行与证据）

推荐分工是“决策权在人工，执行权在 AI”，避免两类常见失败：

- 失败 A：人每一步都微操，导致吞吐极低。
- 失败 B：AI 自行做高风险裁决，导致方向性错误。

建议职责矩阵：

| 事项 | AI 主责 | 人主责 |
| --- | --- | --- |
| 任务拆解与执行 | 是 | 否 |
| 证据收集与报告草稿 | 是 | 否 |
| 架构取舍与风险接受 | 否 | 是 |
| 规则冲突裁决 | 否 | 是 |
| 验收签收 | 否 | 是 |

触发人工裁决的典型场景：

- 多方案成本/风险差异显著
- 涉及破坏性操作或不可逆变更
- 外部依赖、权限、合规边界不明确
- 连续同类失败且证据模式一致

AI 汇报格式建议：

- 已验证事实（含命令与结果）
- 根因假设（置信度）
- 备选方案（成本、风险、耗时）
- 单一待决问题（一次只问一个）

### 5.2 原子任务循环与 Review + Rewind

跨语言重构建议坚持“一个原子任务一个闭环”，防止大批量改动导致不可审计。

推荐循环：

1. 读取任务与验收标准
2. 锁定任务状态（进行中）
3. 最小改动实现
4. 运行最小充分验证
5. 执行 Review + Rewind
6. 更新任务状态（已完成）并提交

Review + Rewind 最小清单：

- 验收标准逐条核对
- 审查要求逐条核对
- 相关测试结果记录
- 改动边界检查（是否越界）
- 已知风险与未覆盖项登记

这套循环的价值是让“失败也可积累”：即便失败，也能沉淀复用证据与边界结论。

### 5.3 审计任务模式与非业务改动边界

当任务目标是审计而非修复时，必须切换为“只出报告，不改业务”模式。

建议审计任务输入：

- 目标变更范围（PR 或文件清单）
- 审计基线（规范、协议、验收标准）
- 可用验证命令（类型检查、测试、门禁）

建议审计任务输出：

- 严重级别排序的问题清单
- 每个问题的定位路径与证据
- 风险影响面与复现条件
- 修复任务建议（写回台账，而不是现场混修）

非业务改动边界：

- 审计任务默认不改 `src` 业务逻辑。
- 允许修改审计报告与台账条目。
- 若必须热修，需显式升级为修复任务并重新走验收循环。

### 5.4 跨会话交接最小信息集

跨会话损耗主要来自“上下文丢失”。建议 handoff 至少包含 10 个字段：

- 当前分支与最新提交
- 当前任务 ID 与状态
- 已完成事项（带证据路径）
- 未完成事项（带阻塞原因）
- 最近一次成功验证命令
- 最近一次失败命令与错误摘要
- 关键产物路径（run_id 目录、报告路径）
- 环境前提（VPN、依赖、平台）
- 风险与边界声明
- 接手者第一步动作

交接质量判定标准：

- 接手者无需追问即可执行下一步命令
- 接手者可在 10 分钟内复现当前状态
- 接手者可定位“为什么卡住”

### 5.5 常见协作失效模式与兜底规则

典型失效模式：

- 只汇报结论，不给证据
- 重复尝试同一策略，不更新假设
- 用临时文档替代任务台账
- 为“看起来通过”引入静默 fallback
- 一次提交混入多个任务改动

兜底规则（可复用）：

- 无证据结论视为无效
- 同类失败两次后必须换策略或升级求助
- 任务状态以台账为准，临时文档仅作缓存
- 禁止静默降级；失败要可观测
- 超出任务边界的改动必须拆分

协作健康度指标（建议每周统计）：

- 原子任务平均完成时长
- 无证据回报占比
- 文档状态漂移次数
- 重复失败次数
- 返工率（同一问题二次修复）

### 5.6 Harness Engineering 交互协议（通用）

本节给出可直接复用的 harness 协作协议，用于控制“自主执行”与“人工介入”的边界。

#### 协议 1：先定义成功与边界

开始前必须明确：

- 交付物
- 验收标准
- 不可改动范围
- 可接受失败范围（重试次数、探索时长）

#### 协议 2：权限分层执行（L1-L4）

- `L1`：只读代码与文档
- `L2`：可运行测试与静态检查
- `L3`：可修改代码并回归
- `L4`：可执行高风险或外部授权操作

升级原则：

- 仅在上一层证据表明“能力不足以完成目标”时升级
- 每次升级必须记录触发条件与回滚条件

#### 协议 3：探索预算与换策略规则

- 给每个问题设置预算（例如 20 分钟或 3 次同类尝试）
- 同手段连续失败 2 次后禁止无脑重试，必须换假设/换路径
- 每轮尝试都要产出证据：动作、结果、下一步假设

#### 协议 4：主动求助触发阈值

满足任一条件应主动请求人工决策：

- 同类失败 2-3 次且错误模式一致
- 缺关键上下文（需求口径、权限、环境变量）
- 需要越过安全边界或做不可逆操作
- 多方案成本/风险显著分化

#### 协议 5：选项型提问模板

```text
当前阻塞: <一句话>
已验证事实:
1) <证据1>
2) <证据2>

可选决策:
- A(推荐): <方案> | 成本 <x> | 风险 <y> | 耗时 <z>
- B: <方案> | 成本 <x> | 风险 <y> | 耗时 <z>
- C: <方案> | 成本 <x> | 风险 <y> | 耗时 <z>

需要确认: <一个决策点>
```

#### 协议 6：交付收束格式

每轮交付最少包含：

- 变更清单（文件与行为）
- 验证证据（命令、结果、失败与修复）
- 已知风险与未覆盖边界

禁止“只说已完成，不给证据”。

## 6. 反常识心法（跨 context 沉淀）

### 6.1 口径一致性比“代码优雅”更优先

跨语言阶段，首要目标不是“最优实现”，而是“语义口径稳定”。  
如果口径未统一，代码再优雅也会导致结果不可比、测试不可判。

实践要点：

- 先冻结指标口径（单位、字段、事件语义）
- 再做实现迁移与重构
- 最后才做结构优化与性能精调

### 6.2 不删桥接不代表稳妥，证据完备后应收敛

常见误区是“保留旧桥接最安全”。实际上，长期双路径并存会提高维护成本并扩大漂移面。

正确做法：

- 在等价测试与回归证据完备后，计划性退役桥接层
- 删除前后都要有对照报告
- 删除动作必须绑定验收项与回滚预案

结论：删除冗余不是简化业务，而是收敛技术债。

### 6.3 性能结论先验条件：负载可比

性能数字只有在负载可比前提下才有意义。  
若输入路径、事件量、调用次数不同，速度结论不应进入决策。

执行纪律：

- compare 必须输出可比性字段
- gate 必须验证可比性元数据
- 报告必须标注哪些结论可用、哪些仅供参考

### 6.4 文档不是事实源，台账才是

迁移项目往往文档很多，但真正可执行的事实源应保持单一。  
文档用于解释和教学，台账用于驱动执行与状态判断。

实践纪律：

- 状态冲突时先信台账，再修文档
- 文档结论必须反向链接到台账和提交证据
- 临时 handoff 到期即归档，避免“僵尸状态”持续传播

### 6.5 规则与现实冲突时的处理顺序

任何规则都会遇到现实约束。关键不是“有没有冲突”，而是“如何显式处理冲突”。

建议顺序：

1. 先记录冲突事实（规则条款 vs 现实现状）
2. 评估风险（是否影响正确性、安全、可审计性）
3. 选择处置策略（豁免、过渡、重构）
4. 写回文档与检查脚本，避免重复争论

常见冲突类型：

- 规范阈值与历史代码体量冲突
- 审计流程引用文件缺失
- 编码规范与历史文档存量不一致

核心原则是“显式化 + 可回放”，而不是“默认忽略”。

## 7. 规则清单与可执行检查项（可复用）

### 7.1 编码与注释输出规范

跨语言团队最易忽视的是“输出规范一致性”。建议最小强制项如下：

- 禁止在代码、注释、日志中使用装饰性符号与表情
- 注释使用纯文本，语义清晰，避免空洞描述
- 公共接口必须有参数、返回值、异常语义说明
- 注释变更与代码变更同步提交

快速检查命令（示例）：

```bash
rg -n "✅|❌|⚠️|🚫|🎯|✓|►|▼|●|★|✦|✧" --glob "*.rs" --glob "*.py" --glob "*.ts"
```

### 7.2 功能完整性保护与变更边界

“不简化功能”应落到可执行检查，而不是口号。

建议规则：

- 任何删除必须有影响分析与验收证据
- 不允许为过测引入隐藏分支或静默 fallback
- 不允许跨任务顺手改 unrelated 逻辑
- 改动边界以任务验收描述为准

建议检查：

```bash
# 改动边界检查
git diff --name-only

# 关键行为回归
make test-equiv-rust
make test-equiv-python
python scripts/perf/perf_ci_gate.py --policy warning
```

### 7.3 安全与配置管理基线

跨语言重构常见风险不是算法，而是配置与凭证失控。

最小基线：

- 源码不得硬编码凭证与密钥
- 参数化访问数据库，禁止拼接查询
- 环境变量分层管理（dev/staging/prod）
- 配置来源优先级明确并可追踪

建议检查：

```bash
# 粗筛潜在密钥
rg -n "API_KEY|SECRET|TOKEN|PASSWORD|PRIVATE_KEY" .

# 配置字段与文档一致性（按项目脚本替换）
python scripts/perf/validate_pair_manifest.py --manifest tests/perf/pairs/pair_manifest.csv
```

### 7.4 可执行检查命令清单

以下命令可作为跨语言迁移的最小日常检查集：

```bash
# 1) 台账状态统计
python - <<'PY'
import csv
from collections import Counter
rows=list(csv.DictReader(open('issues.csv',encoding='utf-8-sig')))
print(Counter(r['State'] for r in rows))
PY

# 2) 禁内联测试
bash scripts/check_no_inline_tests.sh

# 3) 等价编排
python scripts/equiv/run_equiv_suite.py --stages rust,python

# 4) 性能 compare + gate
python scripts/perf/compare_pair_perf.py
python scripts/perf/perf_ci_gate.py --profile offline --policy warning

# 5) full profile（外部依赖场景）
python scripts/perf/perf_ci_gate.py --profile full --policy strict
```

团队可根据项目规模扩展该清单，但不建议低于以上最小集。

## 8. 附录（模板与清单）

### 8.1 新项目落地清单（第一周）

```md
#### Day 1: 盘点与基线
- [ ] 明确单一事实源（任务台账）
- [ ] 建立阶段划分与证据索引
- [ ] 识别外部依赖与平台边界

#### Day 2-3: 测试资产化
- [ ] 抽离内联测试到独立目录
- [ ] 建立单元/等价/回归分层
- [ ] 固化最小可执行测试命令

#### Day 4-5: 等价与性能平台
- [ ] 建立 run_id + run_manifest 编排
- [ ] 建立 pair_manifest 与 compare/gate
- [ ] 接入 CI 与 artifact 上传

#### Day 6-7: 审计与收口
- [ ] 输出阶段审计三件套
- [ ] 建立漂移巡检清单
- [ ] 形成首版知识库与交接模板
```

### 8.2 阶段验收报告模板

```md
# 阶段验收报告（<阶段名>）

## 1. 结论摘要
- 截止时间：
- 验收结论：
- 台账状态：
- 行为等价：
- 性能门禁：

## 2. 证据索引
- 任务台账：
- 提交记录：
- 回归报告：
- 门禁报告：

## 3. 风险与边界
- 外部依赖：
- 平台覆盖：
- profile 覆盖：
- 已知风险：
- 不在范围：

## 4. 复现命令
- `<command-1>`
- `<command-2>`
```

### 8.3 跨平台验证记录模板（Linux/Windows）

```md
# 跨平台验证记录（<任务ID>）

## 环境信息
- Linux:
  - OS:
  - Python:
  - Rust:
- Windows:
  - OS:
  - Python:
  - Rust:

## 前置条件
- VPN:
- 外部依赖:
- 环境变量:

## 执行命令与结果
| 平台 | 命令 | 结果 | 关键输出 |
| --- | --- | --- | --- |
| Linux | ... | pass/fail | ... |
| Windows | ... | pass/fail | ... |

## 差异与结论
- 差异点：
- 归因：
- 最终结论：
```

### 8.4 漂移审计模板（文档 vs 代码 vs 台账）

```md
# 漂移审计（<日期>）

## 审计范围
- 文档集合：
- 代码目录：
- 台账范围：

## 漂移发现
| 漂移类型 | 位置 | 事实描述 | 风险级别 | 处理状态 |
| --- | --- | --- | --- | --- |
| 状态漂移 | ... | ... | P1/P2/P3 | open/closed |
| 规则漂移 | ... | ... | P1/P2/P3 | open/closed |
| 执行漂移 | ... | ... | P1/P2/P3 | open/closed |

## 修复动作
- [ ] 修正文档
- [ ] 补充检查脚本
- [ ] 更新 CI 门禁
- [ ] 回写台账

## 复核结论
- 复核人：
- 复核时间：
- 结论：
```
